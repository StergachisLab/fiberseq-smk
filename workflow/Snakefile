from snakemake.utils import min_version

min_version("7.8")


include: "rules/common.smk"


scattergather:
    chunks=20,


env = config.pop("env", "envs/env.yml")
ref = config.pop("ref", None)
n_chunks = len(scatter.chunks("temp/{scatteritem}.fake"))
output_types = ["m6a", "cpg", "nuc", "msp"]


wildcard_constraints:
    sm="|".join(config.keys()),


rule all:
    input:
        expand("results/{sm}/unaligned.fiberseq.bam", sm=list(config.keys())),
        expand("results/{sm}/unaligned.fiberseq.bam.pbi", sm=list(config.keys())),
        align_results(list(config.keys())),
        expand(
            "results/{sm}/{aligned}.{data}.bed.gz",
            aligned=["aligned", "unaligned"],
            sm=list(config.keys()),
            data=output_types,
        ),
        expand(
            "results/{sm}/aligned.{data}.bed.bb",
            sm=list(config.keys()),
            data=output_types,
        ),


rule ccs:
    input:
        bam=get_subreads,
    output:
        bam=temp("temp/{sm}/ccs.{scatteritem}.bam"),
        pbi=temp("temp/{sm}/ccs.{scatteritem}.bam.pbi"),
        json=temp("temp/{sm}/ccs.{scatteritem}.zmw_metrics.json.gz"),
        txt=temp("temp/{sm}/ccs.{scatteritem}.ccs_report.txt"),
    resources:
        mem_mb=16 * 1024,
    threads: config.get("threads", 8)
    conda:
        env
    log:
        "logs/{sm}/ccs.{scatteritem}.log",
    benchmark:
        "benchmarks/{sm}/ccs.{scatteritem}.tbl"
    params:
        chunk=get_chunk,
    priority: 0
    shell:
        """
        ccs {input.bam} {output.bam} \
            --metrics-json {output.json} \
            --report-file {output.txt} \
            --hifi-kinetics -j {threads} \
            --chunk {params.chunk} \
        &> {log}
        """


rule primrose:
    input:
        bam=rules.ccs.output.bam,
    output:
        bam=temp("temp/{sm}/primrose.{scatteritem}.bam"),
    threads: config.get("threads", 8)
    conda:
        env
    log:
        "logs/{sm}/primrose.{scatteritem}.log",
    benchmark:
        "benchmarks/{sm}/primrose.{scatteritem}.tbl"
    priority: 0
    shell:
        """
        primrose --min-passes 3 -j {threads} \
             --keep-kinetics \
            {input.bam} {output.bam} \
            &> {log}
        """


rule actc:
    input:
        ccs=rules.primrose.output.bam,
        subreads=get_subreads,
    output:
        bam=temp("temp/{sm}/actc.{scatteritem}.bam"),
        fasta=temp("temp/{sm}/actc.{scatteritem}.fasta"),
    threads: config.get("threads", 8)
    conda:
        env
    log:
        "logs/{sm}/actc.{scatteritem}.log",
    benchmark:
        "benchmarks/{sm}/actc.{scatteritem}.tbl"
    priority: 10
    shell:
        """
        actc -j {threads} {input.subreads} {input.ccs} {output.bam} 2> {log}
        """


rule index:
    input:
        bam=rules.actc.output.bam,
    output:
        pbi=temp(f"{rules.actc.output.bam}.pbi"),
    threads: 1
    conda:
        env
    log:
        "logs/{sm}/index.{scatteritem}.log",
    benchmark:
        "benchmarks/{sm}/index.{scatteritem}.tbl"
    priority: 20
    shell:
        """
        pbindex {input.bam} &> {log}
        """


rule ccs_fasta:
    input:
        ccs=rules.primrose.output.bam,
    output:
        fasta=temp("temp/{sm}/ccs.{scatteritem}.fasta"),
        fai=temp("temp/{sm}/ccs.{scatteritem}.fasta.fai"),
    threads: 1
    conda:
        env
    log:
        "logs/{sm}/ccs.fasta.{scatteritem}.log",
    benchmark:
        "benchmarks/{sm}/ccs_fasta.{scatteritem}.tbl"
    priority: 30
    shell:
        """
        samtools fasta -@ {threads} {input.ccs} > {output.fasta} 2> {log}
        samtools faidx {output.fasta} 2>> {log}
        """


rule ipdSummary:
    input:
        ccs_fasta=rules.ccs_fasta.output.fasta,
        fai=rules.ccs_fasta.output.fai,
        actc=rules.actc.output.bam,
        #bai=rules.index.output.bai,
        pbi=rules.index.output.pbi,
    output:
        csv=temp("temp/{sm}/ipdSummary.{scatteritem}.csv"),
    threads: config.get("threads", 8)
    conda:
        env
    resources:
        time=80,
    log:
        "logs/{sm}/ipdSummary.{scatteritem}.log",
    benchmark:
        "benchmarks/{sm}/ipdSummary.{scatteritem}.tbl"
    priority: 40
    shell:
        """
        ipdSummary \
            --reference {input.ccs_fasta} \
            --pvalue 0.001 \
            --numWorkers {threads} \
            --quiet --identify m6A \
            --csv {output.csv} \
            {input.actc} &> {log}
        """


rule gmm:
    input:
        ccs=rules.primrose.output.bam,
        csv=rules.ipdSummary.output.csv,
    output:
        bam=temp("temp/{sm}/gmm.{scatteritem}.bam"),
    threads: 4
    conda:
        env
    log:
        "logs/{sm}/gmm.{scatteritem}.log",
    params:
        gmm=workflow.source_path("scripts/push_m6a_to_bam.py"),
    benchmark:
        "benchmarks/{sm}/gmm.{scatteritem}.tbl"
    priority: 50
    shell:
        """
        python {params.gmm} --threads {threads} {input.csv} {input.ccs} > {output.bam} 2> {log}
        """


rule train_hmm:
    input:
        bam=f"temp/{{sm}}/gmm.1-of-{n_chunks}.bam",
    output:
        model=temp("temp/{sm}/hmm_model.json"),
    conda:
        env
    log:
        "logs/{sm}/train_hmm.log",
    params:
        nuc=workflow.source_path("scripts/add_nucleosomes.py"),
    benchmark:
        "benchmarks/{sm}/train_hmm.tbl"
    resources:
        disk_mb=16000,
        time=200,
    threads: 1
    priority: 60
    shell:
        """
        python {params.nuc} --threads {threads} {input.bam} {output.model} 2> {log}
        """


rule nuc:
    input:
        bam=rules.gmm.output.bam,
        model=rules.train_hmm.output.model,
    output:
        bam=temp("temp/{sm}/nuc.{scatteritem}.bam"),
    conda:
        env
    log:
        "logs/{sm}/nuc.{scatteritem}.log",
    params:
        nuc=workflow.source_path("scripts/add_nucleosomes.py"),
    benchmark:
        "benchmarks/{sm}/nuc.{scatteritem}.tbl"
    threads: 4
    priority: 70
    shell:
        """
        python {params.nuc} -m {input.model} --threads {threads} {input.bam} {output.bam} 2> {log}
        """


rule merge:
    input:
        bam=gather.chunks(rules.nuc.output.bam, allow_missing=True),
        pbi=gather.chunks(rules.ccs.output.pbi, allow_missing=True),
    output:
        bam="results/{sm}/unaligned.fiberseq.bam",
    conda:
        env
    log:
        "logs/{sm}/samtools.cat.log",
    resources:
        disk_mb=8000,
        time=120,
    threads: 4
    benchmark:
        "benchmarks/{sm}/merge.tbl"
    priority: 100
    shell:
        """
        samtools cat -@ {threads} -o {output.bam} {input.bam} 2> {log}
        """


rule index_merge:
    input:
        bam=rules.merge.output.bam,
    output:
        pbi=f"{rules.merge.output.bam}.pbi",
    conda:
        env
    log:
        "logs/{sm}/samtools.cat.log",
    benchmark:
        "benchmarks/{sm}/index.tbl"
    threads: 1
    priority: 100
    shell:
        """
        pbindex {input.bam} &> {log}
        """


rule align:
    input:
        bam=rules.merge.output.bam,
        ref=ref,
    output:
        bam="results/{sm}/aligned.fiberseq.bam",
        bai="results/{sm}/aligned.fiberseq.bam.bai",
    conda:
        env
    log:
        "logs/{sm}/align.log",
    resources:
        disk_mb=8000,
        time=240,
    threads: 40
    benchmark:
        "benchmarks/{sm}/align.tbl"
    priority: 200
    shell:
        """
        pbmm2 align \
            -j {threads} \
            --preset CCS --sort \
            {input.ref} {input.bam} {output.bam} \
        2> {log}
        """


rule make_aligned_beds:
    input:
        bam="results/{sm}/{aligned}.fiberseq.bam",
    output:
        cpg=temp("temp/{sm}/{aligned}.cpg.bed"),
        msp=temp("temp/{sm}/{aligned}.msp.bed"),
        m6a=temp("temp/{sm}/{aligned}.m6a.bed"),
        nuc=temp("temp/{sm}/{aligned}.nuc.bed"),
    conda:
        env
    log:
        "logs/{sm}/{aligned}_beds.log",
    resources:
        disk_mb=8000,
        time=240,
    threads: 4
    benchmark:
        "benchmarks/{sm}/{aligned}_beds.tbl"
    params:
        extract=workflow.source_path("scripts/extract_bed_from_bam.py"),
        aligned=lambda wc: "-r" if wc.aligned == "aligned" else "",
    priority: 300
    shell:
        """
        python {params.extract} \
            {params.aligned} {input.bam} \
             --cpg {output.cpg} --msp {output.msp} \
             --m6a {output.m6a} --nuc {output.nuc} \
            2> {log}
        """


rule compress_bed:
    input:
        bed="results/{sm}/{aligned}.{data}.bed",
    output:
        bed="results/{sm}/{aligned}.{data}.bed.gz",
    conda:
        env
    log:
        "logs/{sm}/compress_bed_{aligned}_{data}.log",
    threads: 4
    benchmark:
        "benchmarks/{sm}/compress_bed_{aligned}_{data}.tbl"
    priority: 300
    shell:
        """
        cat {input.bed} | bgzip -@ {threads} > {output.bed}
        """


rule bigbed:
    input:
        fai=f"{ref}.fai",
        bed="temp/{sm}/aligned.{data}.bed",
    output:
        bb="results/{sm}/aligned.{data}.bed.bb",
    conda:
        env
    log:
        "logs/{sm}/bigbed_{data}.log",
    benchmark:
        "benchmarks/{sm}/bigbed_{data}.tbl"
    priority: 300
    shell:
        """
        bedToBigBed {input.bed} {input.fai} {output.bb}
        """
